[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"3d-pbr",[{"hash":2549600038,"record":null,"name":"3d-pbr|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n#if CC_USE_SKINNING\n  in vec4 a_weights;\n  in vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform SKINNING {\n      vec2 jointsTextureSize;\n    };\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform JOINT_MATRIX {\n      mat4 jointMatrices[50];\n    };\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nin vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nin vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nin vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nin vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nin vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform CC_SHADOW {\n    mat4 cc_shadow_lightViewProjMatrix[2];\n    vec4 cc_shadow_info[2];\n  };\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\nvoid CCShadowInput (vec3 worldPos) {\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_SHADOW_LIGHTS; i++) {\n    v_posLightSpace[i] = cc_shadow_lightViewProjMatrix[i] * vec4(worldPos, 1.0);\n    v_depth[i] = (v_posLightSpace[i].z + cc_shadow_info[i].x) / (cc_shadow_info[i].x + cc_shadow_info[i].y);\n  }\n  #endif\n}\nout vec3 v_worldNormal;\nout vec3 v_worldPos;\nout vec3 v_viewDirection;\nout vec2 v_uv0;\n#if USE_NORMAL_MAP\nout vec3 v_bitangent;\nout vec3 v_tangent;\n#endif\nvoid QD_VertexInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n      In.tangent = m * In.tangent;\n  #endif\n}\nvoid main () {\n  StandardVertInput In;\n  QD_VertexInput(In);\n  vec4 position = In.position;\n  v_worldNormal = normalize((cc_matWorldIT * vec4(In.normal, 0)).xyz);\n  v_worldPos = (cc_matWorld * position).xyz;\n  v_uv0 = a_uv0;\n#if USE_NORMAL_MAP\n  v_tangent = normalize((cc_matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = cross(v_worldNormal, v_tangent) * In.tangent.w;\n#endif\n  CCShadowInput(v_worldPos);\n  gl_Position = cc_matViewProj * cc_matWorld * position;\n}","frag":"\n#extension GL_EXT_shader_texture_lod : enable\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform PhongFrag {\n  lowp vec4 albedoColor;\n  lowp vec4 mainLightColor;\n  lowp vec4 mainLightPosition;\n  lowp vec4 skyAmbant;\n  lowp vec4 groundAmbant;\n  lowp float NdotLWeight;\n  lowp float fresnelPow;\n  highp float metallic;\n  lowp float mainLightIntensity;\n  mediump float smoothness;\n};\n  uniform sampler2D baseMap;\n  uniform sampler2D bumpMap;\n  uniform sampler2D matcap;\n#if USE_NORMAL_MAP\nin vec3 v_bitangent;\nin vec3 v_tangent;\n#endif\nin vec3 v_worldNormal;\nin vec3 v_worldPos;\nin vec3 v_viewDirection;\nin vec2 v_uv0;\nstruct SurfaceData\n{\n    vec3 PositionWS;\n    vec3 NormalWS;\n    float Smoothness;\n    float Metallic;\n    vec2 uv;\n};\nstruct PBRVariables\n{\n    float PerceptualRoughness;\n    float Roughness;\n    float Roughness2;\n    float Roughness2MinusOne;\n    float NormalizationTerm;\n    float NdotV;\n    vec3 viewDir;\n    vec3 F0;\n    vec3 DiffuseColor;\n};\nmat3 buildTTW(vec3 tangentWS, vec3 normalWS)\n{\n  vec3 bitangentWS = cross(tangentWS, normalWS);\n  return mat3(tangentWS, bitangentWS, normalWS);\n}\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\nfloat PerceptualSmoothnessToPerceptualRoughness(float perceptualSmoothness)\n{\n    return (1.0 - perceptualSmoothness);\n}\nvec3 NormalizePerPixel(vec3 vNormal)\n{\n  return normalize(vNormal);\n}\nvec3 unpackNormal(vec2 packedNormal)\n{\n  vec3 normal;\n#if REVERSE_NORMAL\n  normal.x = (1.0 - packedNormal.x) * 2.0 - 1.0;\n  normal.y = (1.0 - packedNormal.y) * 2.0 - 1.0;\n#else\n  normal.x = (packedNormal.x) * 2.0 - 1.0;\n  normal.y = (packedNormal.y) * 2.0 - 1.0;\n#endif\n  normal.z = sqrt(1.0 - dot(normal.xy, normal.xy));\n  return normal;\n}\nSurfaceData PreCalcSurfaceData(float metallic, float smoothness, vec3 positionWS, vec2 uv, vec3 tangent, vec3 worldNormal)\n{\n    SurfaceData surfaceData;\n#if USE_NORMAL_MAP\n    vec3 normalTS = unpackNormal(texture2D(bumpMap, uv).xy);\n    mat3 ttw = buildTTW(tangent, worldNormal);\n    vec3 normalWS = ttw * normalTS;\n    normalWS = NormalizePerPixel(worldNormal);\n#else\n    vec3 normalWS = NormalizePerPixel(worldNormal);\n#endif\n    surfaceData.PositionWS = positionWS.xyz;\n    surfaceData.NormalWS = normalWS;\n    surfaceData.Smoothness = smoothness;\n    surfaceData.Metallic = metallic;\n    surfaceData.uv = uv;\n    return surfaceData;\n}\nPBRVariables PreCalcPBRVariables(SurfaceData surfaceData, vec3 Albedo)\n{\n    float Metallic              = clamp(surfaceData.Metallic, 0.0, 1.0);\n    float Smoothness            = clamp(surfaceData.Smoothness, 0.0, 1.0);\n    float PerceptualRoughness   = PerceptualSmoothnessToPerceptualRoughness(Smoothness);\n    float Roughness             = max(PerceptualRoughnessToRoughness(PerceptualRoughness), 0.0078125);\n    float Roughness2            = max(Roughness * Roughness, 6.103515625e-5);\n    float NormalizationTerm     = Roughness * 4.0 + 2.0;\n    float Roughness2MinusOne    = max(Roughness2, 6.103515625e-5) - 1.0;\n    float oneMinusReflectivity = (1.0 - Metallic) * 0.96;\n    vec3 diffuseColor = Albedo.rgb * oneMinusReflectivity;\n    vec3 F0 = mix(vec3(0.04, 0.04, 0.04), Albedo.rgb, Metallic);\n    PBRVariables pbrVariables;\n    pbrVariables.PerceptualRoughness = PerceptualRoughness;\n    pbrVariables.Roughness = Roughness;\n    pbrVariables.Roughness2 = Roughness2;\n    pbrVariables.Roughness2MinusOne = Roughness2MinusOne;\n    pbrVariables.NormalizationTerm = NormalizationTerm;\n    pbrVariables.F0 = F0;\n    pbrVariables.DiffuseColor = diffuseColor;\n    pbrVariables.viewDir = vec3(0.0, 0.0, 1.0);\n    pbrVariables.NdotV = clamp(dot(surfaceData.NormalWS, pbrVariables.viewDir), 0.001, 1.0);\n    return pbrVariables;\n}\nvec4 sampleMatcapReflectionColor(vec3 viewDir, vec3 worldNormal, float Roughness, float Smoothness)\n{\n  vec4 IndirSpeMatcapColor = vec4(0.0, 0.0, 0.0, 0.0);\n#if USE_MAPCAP_REFLECTION\n  vec4 reViewDir = cc_matView * vec4(-viewDir, 1.0);\n  vec2 MatcapUV = (normalize(normalize(reflect(reViewDir.xyz, worldNormal.xyz)) + vec3(0.0, 0.0, 1.0)).xy) * 0.5 + 0.5;\n  float MatcapLOD = Roughness * 6.0 * (1.7 - Roughness * 0.7);\n  IndirSpeMatcapColor = texture2DLodEXT(matcap, vec2(MatcapUV.x, 1.0 - MatcapUV.y), MatcapLOD) * 1.0;\n#endif\n  return IndirSpeMatcapColor;\n}\nvec3 SingleLightPBR(vec3 lightDir, vec3 lightColor, PBRVariables pbrVariables, SurfaceData surfaceData, float distanceAttenuation)\n{\n    vec3 HalfDir = normalize(lightDir + pbrVariables.viewDir);\n    float NdotH = clamp(dot(surfaceData.NormalWS, HalfDir), 0.0, 1.0);\n    float NdotL = clamp(dot(surfaceData.NormalWS, lightDir), 0.0, 1.0);\n#if USE_LAMBERT_WEIGHT\n    NdotL = NdotL * NdotLWeight + (1.0 - NdotLWeight);\n#endif\n    float LdotH = clamp(dot(lightDir, HalfDir), 0.0, 1.0);\n    float D = NdotH * NdotH * pbrVariables.Roughness2MinusOne + 1.00001;\n    float D2 = D * D;\n    float LdotH2 = LdotH * LdotH;\n    float SpecularTerm = pbrVariables.Roughness2 / (D2 * max(float(0.1), LdotH2) * pbrVariables.NormalizationTerm);\n    SpecularTerm = SpecularTerm - 6.103515625e-5;\n    SpecularTerm = clamp(SpecularTerm, 0.0, 100.0);\n    float radiance = NdotL * distanceAttenuation;\n    vec3 color = (pbrVariables.DiffuseColor + pbrVariables.F0 * SpecularTerm) * lightColor;\n    color *= radiance;\n    return color;\n}\nvoid main () {\n  SurfaceData surfaceData = PreCalcSurfaceData(metallic, smoothness, v_worldPos, v_uv0, v_tangent, v_worldNormal);\n  vec4 baseColor = albedoColor;\n#if USE_ALBEDO_TEXTURE\n  baseColor *= texture2D(baseMap, surfaceData.uv);\n#endif\n  PBRVariables pbrDatas = PreCalcPBRVariables(surfaceData, baseColor.rgb);\n  vec3 lightDir = normalize(mainLightPosition.xyz - surfaceData.PositionWS.xyz);\n  vec3 mainLightColor = mainLightColor.rgb * mainLightIntensity;\n  vec3 lightColor = SingleLightPBR(lightDir, mainLightColor, pbrDatas, surfaceData, 1.0);\n  float NdotV = max(dot(surfaceData.NormalWS, pbrDatas.viewDir), 0.0);\n  float grazeTerm = clamp(surfaceData.Smoothness + surfaceData.Metallic, 0.0, 1.0);\n#if USE_MAPCAP_REFLECTION\n  #ifdef GL_EXT_shader_texture_lod\n    vec3 GI = sampleMatcapReflectionColor(pbrDatas.viewDir, surfaceData.NormalWS, pbrDatas.Roughness, surfaceData.Smoothness).rgb;\n  #else\n    vec3 GI = mix(groundAmbant.rgb, skyAmbant.rgb, (surfaceData.NormalWS.y + 1.0) * 0.5);\n  #endif\n#else\n    vec3 GI = mix(groundAmbant.rgb, skyAmbant.rgb, (surfaceData.NormalWS.y + 1.0) * 0.5);\n#endif\n  vec3 fresnelTerm = mix(pbrDatas.F0, vec3(grazeTerm), pow(1.0 - NdotV, fresnelPow));\n  vec3 glossReflection = GI * fresnelTerm * (surfaceData.Smoothness * 0.5 + 0.5);\n  vec3 finalColor = clamp(lightColor.rgb, 0.0, 1.0) + clamp(glossReflection.rgb, 0.0, 1.0);\n  gl_FragColor = vec4(finalColor, baseColor.a);\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\nuniform mat4 cc_matViewProj;\n#if CC_USE_SKINNING\n  attribute vec4 a_weights;\n  attribute vec4 a_joints;\n  #if CC_USE_JOINTS_TEXTRUE\n    uniform vec2 jointsTextureSize;\n    uniform sampler2D jointsTexture;\n    #if CC_JOINTS_TEXTURE_FLOAT32\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 4.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = texture2D(jointsTexture, vec2(dx * (x + 0.5), y));\n        vec4 v2 = texture2D(jointsTexture, vec2(dx * (x + 1.5), y));\n        vec4 v3 = texture2D(jointsTexture, vec2(dx * (x + 2.5), y));\n        vec4 v4 = texture2D(jointsTexture, vec2(dx * (x + 3.5), y));\n        return mat4(v1, v2, v3, v4);\n      }\n    #else\n      float decode32(vec4 rgba) {\n        float Sign = 1.0 - step(128.0, rgba[0]) * 2.0;\n        float Exponent = 2.0 * mod(rgba[0], 128.0) + step(128.0, rgba[1]) - 127.0;\n        float Mantissa = mod(rgba[1], 128.0) * 65536.0 + rgba[2] * 256.0 + rgba[3] + 8388608.0;\n        return Sign * exp2(Exponent - 23.0) * Mantissa;\n      }\n      vec4 decodevec4 (vec4 x, vec4 y, vec4 z, vec4 w) {\n        return vec4(\n          decode32(x.wzyx * 255.0),\n          decode32(y.wzyx * 255.0),\n          decode32(z.wzyx * 255.0),\n          decode32(w.wzyx * 255.0)\n        );\n      }\n      vec4 decodevec4 (float dx, float x, float y) {\n        return decodevec4(\n          texture2D(jointsTexture, vec2(dx * (x + 0.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 1.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 2.5), y)),\n          texture2D(jointsTexture, vec2(dx * (x + 3.5), y))\n        );\n      }\n      mat4 getBoneMatrix(const in float i) {\n        float width = jointsTextureSize.x;\n        float height = jointsTextureSize.y;\n        float j = i * 16.0;\n        float x = mod(j, width);\n        float y = floor(j / width);\n        float dx = 1.0 / width;\n        float dy = 1.0 / height;\n        y = dy * (y + 0.5);\n        vec4 v1 = decodevec4(dx, x,       y);\n        vec4 v2 = decodevec4(dx, x+4.0,   y);\n        vec4 v3 = decodevec4(dx, x+8.0,   y);\n        vec4 v4 = decodevec4(dx, x+12.0,  y);\n        return mat4(v1, v2, v3, v4);\n      }\n    #endif\n  #else\n    uniform mat4 jointMatrices[50];\n    mat4 getBoneMatrix(const in float i) {\n      return jointMatrices[int(i)];\n    }\n  #endif\n    mat4 skinMatrix() {\n      return\n        getBoneMatrix(a_joints.x) * a_weights.x +\n        getBoneMatrix(a_joints.y) * a_weights.y +\n        getBoneMatrix(a_joints.z) * a_weights.z +\n        getBoneMatrix(a_joints.w) * a_weights.w\n        ;\n    }\n#endif\nstruct StandardVertInput {\n  vec2 uv;\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n  vec4 color;\n};\nattribute vec3 a_position;\n#if CC_USE_ATTRIBUTE_UV0\nattribute vec2 a_uv0;\n#endif\n#if CC_USE_ATTRIBUTE_COLOR\nattribute vec4 a_color;\n#endif\n#if CC_USE_ATTRIBUTE_NORMAL\nattribute vec3 a_normal;\n#endif\n#if CC_USE_ATTRIBUTE_TANGENT\nattribute vec4 a_tangent;\n#endif\nvoid CCAttribute (out StandardVertInput In) {\n  In.position = vec4(a_position, 1.0);\n  #if CC_USE_ATTRIBUTE_UV0\n    In.uv = a_uv0;\n  #else\n    In.uv = vec2(0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_COLOR\n    In.color = a_color;\n  #else\n    In.color = vec4(1.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_NORMAL\n    In.normal = a_normal;\n  #else\n    In.normal = vec3(0.0, 1.0, 0.0);\n  #endif\n  #if CC_USE_ATTRIBUTE_TANGENT\n    In.tangent = a_tangent;\n  #else\n    In.tangent = vec4(1.0, 0.0, 0.0, 0.0);\n  #endif\n}\n#if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  uniform mat4 cc_shadow_lightViewProjMatrix[2];\nuniform vec4 cc_shadow_info[2];\n  #if CC_NUM_SHADOW_LIGHTS > 0\n    uniform sampler2D cc_shadow_map_0;\n  #endif\n  #if CC_NUM_SHADOW_LIGHTS > 1\n    uniform sampler2D cc_shadow_map_1;\n  #endif\n  varying vec4 v_posLightSpace[2];\n  varying float v_depth[2];\n#endif\nvoid CCShadowInput (vec3 worldPos) {\n  #if CC_USE_SHADOW_MAP && CC_NUM_SHADOW_LIGHTS > 0\n  for (int i = 0; i < CC_NUM_SHADOW_LIGHTS; i++) {\n    v_posLightSpace[i] = cc_shadow_lightViewProjMatrix[i] * vec4(worldPos, 1.0);\n    v_depth[i] = (v_posLightSpace[i].z + cc_shadow_info[i].x) / (cc_shadow_info[i].x + cc_shadow_info[i].y);\n  }\n  #endif\n}\nvarying vec3 v_worldNormal;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewDirection;\nvarying vec2 v_uv0;\n#if USE_NORMAL_MAP\nvarying vec3 v_bitangent;\nvarying vec3 v_tangent;\n#endif\nvoid QD_VertexInput(out StandardVertInput In) {\n  CCAttribute(In);\n  #if CC_USE_SKINNING\n    mat4 m = skinMatrix();\n    In.position = m * In.position;\n    #if CC_USE_ATTRIBUTE_NORMAL\n      In.normal = (m * vec4(In.normal, 0)).xyz;\n    #endif\n      In.tangent = m * In.tangent;\n  #endif\n}\nvoid main () {\n  StandardVertInput In;\n  QD_VertexInput(In);\n  vec4 position = In.position;\n  v_worldNormal = normalize((cc_matWorldIT * vec4(In.normal, 0)).xyz);\n  v_worldPos = (cc_matWorld * position).xyz;\n  v_uv0 = a_uv0;\n#if USE_NORMAL_MAP\n  v_tangent = normalize((cc_matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = cross(v_worldNormal, v_tangent) * In.tangent.w;\n#endif\n  CCShadowInput(v_worldPos);\n  gl_Position = cc_matViewProj * cc_matWorld * position;\n}","frag":"\n#extension GL_EXT_shader_texture_lod : enable\nprecision highp float;\nuniform mat4 cc_matView;\n#if USE_ALPHA_TEST\n#endif\nuniform lowp vec4 albedoColor;\nuniform lowp vec4 mainLightColor;\nuniform lowp vec4 mainLightPosition;\nuniform lowp vec4 skyAmbant;\nuniform lowp vec4 groundAmbant;\nuniform lowp float NdotLWeight;\nuniform lowp float fresnelPow;\nuniform highp float metallic;\nuniform lowp float mainLightIntensity;\nuniform mediump float smoothness;\n  uniform sampler2D baseMap;\n  uniform sampler2D bumpMap;\n  uniform sampler2D matcap;\n#if USE_NORMAL_MAP\nvarying vec3 v_bitangent;\nvarying vec3 v_tangent;\n#endif\nvarying vec3 v_worldNormal;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewDirection;\nvarying vec2 v_uv0;\nstruct SurfaceData\n{\n    vec3 PositionWS;\n    vec3 NormalWS;\n    float Smoothness;\n    float Metallic;\n    vec2 uv;\n};\nstruct PBRVariables\n{\n    float PerceptualRoughness;\n    float Roughness;\n    float Roughness2;\n    float Roughness2MinusOne;\n    float NormalizationTerm;\n    float NdotV;\n    vec3 viewDir;\n    vec3 F0;\n    vec3 DiffuseColor;\n};\nmat3 buildTTW(vec3 tangentWS, vec3 normalWS)\n{\n  vec3 bitangentWS = cross(tangentWS, normalWS);\n  return mat3(tangentWS, bitangentWS, normalWS);\n}\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\nfloat PerceptualSmoothnessToPerceptualRoughness(float perceptualSmoothness)\n{\n    return (1.0 - perceptualSmoothness);\n}\nvec3 NormalizePerPixel(vec3 vNormal)\n{\n  return normalize(vNormal);\n}\nvec3 unpackNormal(vec2 packedNormal)\n{\n  vec3 normal;\n#if REVERSE_NORMAL\n  normal.x = (1.0 - packedNormal.x) * 2.0 - 1.0;\n  normal.y = (1.0 - packedNormal.y) * 2.0 - 1.0;\n#else\n  normal.x = (packedNormal.x) * 2.0 - 1.0;\n  normal.y = (packedNormal.y) * 2.0 - 1.0;\n#endif\n  normal.z = sqrt(1.0 - dot(normal.xy, normal.xy));\n  return normal;\n}\nSurfaceData PreCalcSurfaceData(float metallic, float smoothness, vec3 positionWS, vec2 uv, vec3 tangent, vec3 worldNormal)\n{\n    SurfaceData surfaceData;\n#if USE_NORMAL_MAP\n    vec3 normalTS = unpackNormal(texture2D(bumpMap, uv).xy);\n    mat3 ttw = buildTTW(tangent, worldNormal);\n    vec3 normalWS = ttw * normalTS;\n    normalWS = NormalizePerPixel(worldNormal);\n#else\n    vec3 normalWS = NormalizePerPixel(worldNormal);\n#endif\n    surfaceData.PositionWS = positionWS.xyz;\n    surfaceData.NormalWS = normalWS;\n    surfaceData.Smoothness = smoothness;\n    surfaceData.Metallic = metallic;\n    surfaceData.uv = uv;\n    return surfaceData;\n}\nPBRVariables PreCalcPBRVariables(SurfaceData surfaceData, vec3 Albedo)\n{\n    float Metallic              = clamp(surfaceData.Metallic, 0.0, 1.0);\n    float Smoothness            = clamp(surfaceData.Smoothness, 0.0, 1.0);\n    float PerceptualRoughness   = PerceptualSmoothnessToPerceptualRoughness(Smoothness);\n    float Roughness             = max(PerceptualRoughnessToRoughness(PerceptualRoughness), 0.0078125);\n    float Roughness2            = max(Roughness * Roughness, 6.103515625e-5);\n    float NormalizationTerm     = Roughness * 4.0 + 2.0;\n    float Roughness2MinusOne    = max(Roughness2, 6.103515625e-5) - 1.0;\n    float oneMinusReflectivity = (1.0 - Metallic) * 0.96;\n    vec3 diffuseColor = Albedo.rgb * oneMinusReflectivity;\n    vec3 F0 = mix(vec3(0.04, 0.04, 0.04), Albedo.rgb, Metallic);\n    PBRVariables pbrVariables;\n    pbrVariables.PerceptualRoughness = PerceptualRoughness;\n    pbrVariables.Roughness = Roughness;\n    pbrVariables.Roughness2 = Roughness2;\n    pbrVariables.Roughness2MinusOne = Roughness2MinusOne;\n    pbrVariables.NormalizationTerm = NormalizationTerm;\n    pbrVariables.F0 = F0;\n    pbrVariables.DiffuseColor = diffuseColor;\n    pbrVariables.viewDir = vec3(0.0, 0.0, 1.0);\n    pbrVariables.NdotV = clamp(dot(surfaceData.NormalWS, pbrVariables.viewDir), 0.001, 1.0);\n    return pbrVariables;\n}\nvec4 sampleMatcapReflectionColor(vec3 viewDir, vec3 worldNormal, float Roughness, float Smoothness)\n{\n  vec4 IndirSpeMatcapColor = vec4(0.0, 0.0, 0.0, 0.0);\n#if USE_MAPCAP_REFLECTION\n  vec4 reViewDir = cc_matView * vec4(-viewDir, 1.0);\n  vec2 MatcapUV = (normalize(normalize(reflect(reViewDir.xyz, worldNormal.xyz)) + vec3(0.0, 0.0, 1.0)).xy) * 0.5 + 0.5;\n  float MatcapLOD = Roughness * 6.0 * (1.7 - Roughness * 0.7);\n  IndirSpeMatcapColor = texture2DLodEXT(matcap, vec2(MatcapUV.x, 1.0 - MatcapUV.y), MatcapLOD) * 1.0;\n#endif\n  return IndirSpeMatcapColor;\n}\nvec3 SingleLightPBR(vec3 lightDir, vec3 lightColor, PBRVariables pbrVariables, SurfaceData surfaceData, float distanceAttenuation)\n{\n    vec3 HalfDir = normalize(lightDir + pbrVariables.viewDir);\n    float NdotH = clamp(dot(surfaceData.NormalWS, HalfDir), 0.0, 1.0);\n    float NdotL = clamp(dot(surfaceData.NormalWS, lightDir), 0.0, 1.0);\n#if USE_LAMBERT_WEIGHT\n    NdotL = NdotL * NdotLWeight + (1.0 - NdotLWeight);\n#endif\n    float LdotH = clamp(dot(lightDir, HalfDir), 0.0, 1.0);\n    float D = NdotH * NdotH * pbrVariables.Roughness2MinusOne + 1.00001;\n    float D2 = D * D;\n    float LdotH2 = LdotH * LdotH;\n    float SpecularTerm = pbrVariables.Roughness2 / (D2 * max(float(0.1), LdotH2) * pbrVariables.NormalizationTerm);\n    SpecularTerm = SpecularTerm - 6.103515625e-5;\n    SpecularTerm = clamp(SpecularTerm, 0.0, 100.0);\n    float radiance = NdotL * distanceAttenuation;\n    vec3 color = (pbrVariables.DiffuseColor + pbrVariables.F0 * SpecularTerm) * lightColor;\n    color *= radiance;\n    return color;\n}\nvoid main () {\n  SurfaceData surfaceData = PreCalcSurfaceData(metallic, smoothness, v_worldPos, v_uv0, v_tangent, v_worldNormal);\n  vec4 baseColor = albedoColor;\n#if USE_ALBEDO_TEXTURE\n  baseColor *= texture2D(baseMap, surfaceData.uv);\n#endif\n  PBRVariables pbrDatas = PreCalcPBRVariables(surfaceData, baseColor.rgb);\n  vec3 lightDir = normalize(mainLightPosition.xyz - surfaceData.PositionWS.xyz);\n  vec3 mainLightColor = mainLightColor.rgb * mainLightIntensity;\n  vec3 lightColor = SingleLightPBR(lightDir, mainLightColor, pbrDatas, surfaceData, 1.0);\n  float NdotV = max(dot(surfaceData.NormalWS, pbrDatas.viewDir), 0.0);\n  float grazeTerm = clamp(surfaceData.Smoothness + surfaceData.Metallic, 0.0, 1.0);\n#if USE_MAPCAP_REFLECTION\n  #ifdef GL_EXT_shader_texture_lod\n    vec3 GI = sampleMatcapReflectionColor(pbrDatas.viewDir, surfaceData.NormalWS, pbrDatas.Roughness, surfaceData.Smoothness).rgb;\n  #else\n    vec3 GI = mix(groundAmbant.rgb, skyAmbant.rgb, (surfaceData.NormalWS.y + 1.0) * 0.5);\n  #endif\n#else\n    vec3 GI = mix(groundAmbant.rgb, skyAmbant.rgb, (surfaceData.NormalWS.y + 1.0) * 0.5);\n#endif\n  vec3 fresnelTerm = mix(pbrDatas.F0, vec3(grazeTerm), pow(1.0 - NdotV, fresnelPow));\n  vec3 glossReflection = GI * fresnelTerm * (surfaceData.Smoothness * 0.5 + 0.5);\n  vec3 finalColor = clamp(lightColor.rgb, 0.0, 1.0) + clamp(glossReflection.rgb, 0.0, 1.0);\n  gl_FragColor = vec4(finalColor, baseColor.a);\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CC_SHADOW","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]}],"samplers":[{"name":"cc_shadow_map_0","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]},{"name":"cc_shadow_map_1","defines":["CC_USE_SHADOW_MAP","CC_NUM_SHADOW_LIGHTS"]}]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_JOINTS_TEXTRUE","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"CC_JOINTS_TEXTURE_FLOAT32","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"CC_USE_ATTRIBUTE_UV0","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_COLOR","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_NORMAL","type":"boolean","defines":[]},{"name":"CC_USE_ATTRIBUTE_TANGENT","type":"boolean","defines":[]},{"name":"CC_USE_SHADOW_MAP","type":"boolean","defines":[]},{"name":"CC_NUM_SHADOW_LIGHTS","type":"number","defines":["CC_USE_SHADOW_MAP"],"range":[0,3]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"REVERSE_NORMAL","type":"boolean","defines":[]},{"name":"USE_MAPCAP_REFLECTION","type":"boolean","defines":[]},{"name":"USE_LAMBERT_WEIGHT","type":"boolean","defines":[]},{"name":"USE_ALBEDO_TEXTURE","type":"boolean","defines":[]}],"blocks":[{"name":"SKINNING","binding":0,"members":[{"name":"jointsTextureSize","type":14,"count":1}],"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"JOINT_MATRIX","binding":1,"members":[{"name":"jointMatrices","type":26,"count":50}],"defines":["CC_USE_SKINNING"]},{"name":"ALPHA_TEST","binding":2,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"PhongFrag","binding":3,"members":[{"name":"albedoColor","type":16,"count":1},{"name":"mainLightColor","type":16,"count":1},{"name":"mainLightPosition","type":16,"count":1},{"name":"skyAmbant","type":16,"count":1},{"name":"groundAmbant","type":16,"count":1},{"name":"NdotLWeight","type":13,"count":1},{"name":"fresnelPow","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"mainLightIntensity","type":13,"count":1},{"name":"smoothness","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"jointsTexture","type":29,"count":1,"binding":30,"defines":["CC_USE_SKINNING","CC_USE_JOINTS_TEXTRUE"]},{"name":"baseMap","type":29,"count":1,"binding":31,"defines":[]},{"name":"bumpMap","type":29,"count":1,"binding":32,"defines":[]},{"name":"matcap","type":29,"count":1,"binding":33,"defines":[]}]}],[{"passes":[{"name":"ForwardLit","program":"3d-pbr|vs|fs","rasterizerState":{"cullMode":1029},"blendState":{"targets":[{"blend":true,"blendSrc":770,"blendDst":771}]},"depthStencilState":{"depthTest":true,"depthWrite":true},"properties":{"alphaThreshold":{"type":13,"value":[0.5]},"baseMap":{"value":"white","type":29},"bumpMap":{"value":"white","type":29},"matcap":{"value":"white","type":29},"albedoColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"mainLightColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"skyAmbant":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"groundAmbant":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"NdotLWeight":{"type":13,"value":[1]},"fresnelPow":{"type":13,"value":[4]},"mainLightIntensity":{"type":13,"value":[1]},"mainLightPosition":{"type":16,"value":[1,1,1,1]},"metallic":{"type":13,"value":[0]},"smoothness":{"type":13,"value":[0]}}}]}]]],0,0,[],[],[]]