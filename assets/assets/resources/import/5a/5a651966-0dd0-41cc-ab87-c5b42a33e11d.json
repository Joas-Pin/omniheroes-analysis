[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"forward-lit",[{"hash":777516209,"record":null,"name":"forward-lit|vs|fs","glsl3":{"vert":"\n    precision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nmat3 calcRotateMatrix(vec3 rotation)\n{\n    float cosY = cos(rotation.y);\n    float cosZ = cos(rotation.z);\n    float cosX = cos(rotation.x);\n    float sinZ = sin(rotation.z);\n    float sinX = sin(rotation.x);\n    float sinY = sin(rotation.y);\n    mat3 rotationMatrix = mat3(\n    cosY * cosZ, -cosX * sinZ + sinX * sinY * cosZ, sinX * sinZ + cosX * sinY * cosZ,\n    cosY * sinZ, cosX * cosZ + sinX * sinY * sinZ, -sinX * cosZ + cosX * sinY * sinZ,\n    -sinY, sinX * cosY, cosX * cosY);\n    return rotationMatrix;\n}\nstruct SurfaceData\n{\n    vec3 PositionWS;\n    vec3 NormalWS;\n    float Smoothness;\n    float Metallic;\n    vec2 uv;\n};\nstruct PBRVariables\n{\n    float PerceptualRoughness;\n    float Roughness;\n    float Roughness2;\n    float Roughness2MinusOne;\n    float NormalizationTerm;\n    float NdotV;\n    vec3 viewDir;\n    vec3 F0;\n    vec3 DiffuseColor;\n};\n    in vec3 a_position;\n    in vec4 a_color;\n    out vec4 v_color;\n    out mat3 v_rotateMatrix;\n    #if USE_TEXTURE\n    in vec2 a_uv0;\n    out vec2 v_uv0;\n    out vec3 v_worldPos;\n    #endif\n    uniform Input {\n        vec4 rotationXYZ;\n        vec2 offsetXY;\n    };\n    void main () {\n        vec4 pos = vec4(a_position, 1);\n#if USE_ROTATOR\n        v_rotateMatrix = calcRotateMatrix(rotationXYZ.xyz);\n        pos.xy = pos.xy - offsetXY;\n        vec3 rotatedPos = v_rotateMatrix * pos.xyz;\n        rotatedPos.xy += offsetXY;\n#else\n        vec3 rotatedPos = pos.xyz;\n#endif\n        v_worldPos.xyz = (cc_matWorld * vec4(rotatedPos, 1.0)).xyz;\n      #if CC_USE_MODEL\n        pos = cc_matViewProj * cc_matWorld * pos;\n      #else\n        pos = cc_matViewProj * vec4(rotatedPos, 1.0);\n      #endif\n      #if USE_TEXTURE\n        v_uv0 = a_uv0;\n      #endif\n        v_color = a_color;\n        gl_Position = pos;\n    }","frag":"\n    precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\n    in vec4 v_color;\n    #if USE_TEXTURE\n        in vec2 v_uv0;\n        in vec3 v_worldPos;\n        in mat3 v_rotateMatrix;\n        uniform sampler2D texture;\n        uniform sampler2D bumpMap;\n        uniform sampler2D maskMap;\n    #endif\n    uniform Constant {\n        vec4 albedoColor;\n        vec4 emissionColor;\n        vec4 lightPos;\n        vec4 lightColor;\n        vec4 secondLightPos;\n        vec4 secondLightColor;\n        vec4 akyAmbient;\n        vec4 groundLineAmbient;\n        vec4 groundAmbient;\n        vec4 normalTilingOffset;\n        float metallic;\n        float smoothness;\n        float NdotLWeight;\n        float normalInt;\n        float emissionIntensity;\n        float lightRadio;\n        float lightReducePow;\n        float lightInt;\n        float secondLightRadio;\n        float secondLightReducePow;\n        float secondLightInt;\n        float ambientIntensity;\n    };\nstruct SurfaceData\n{\n    vec3 PositionWS;\n    vec3 NormalWS;\n    float Smoothness;\n    float Metallic;\n    vec2 uv;\n};\nstruct PBRVariables\n{\n    float PerceptualRoughness;\n    float Roughness;\n    float Roughness2;\n    float Roughness2MinusOne;\n    float NormalizationTerm;\n    float NdotV;\n    vec3 viewDir;\n    vec3 F0;\n    vec3 DiffuseColor;\n};\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\nfloat PerceptualSmoothnessToPerceptualRoughness(float perceptualSmoothness)\n{\n    return (1.0 - perceptualSmoothness);\n}\nvec3 NormalizePerPixel(vec3 vNormal)\n{\n  return normalize(vNormal);\n}\nvec3 unpackNormal(vec2 packedNormal)\n{\n  vec3 normal;\n#if REVERSE_NORMAL\n  normal.x = (1.0 - packedNormal.x) * 2.0 - 1.0;\n  normal.y = (1.0 - packedNormal.y) * 2.0 - 1.0;\n#else\n  normal.x = (packedNormal.x) * 2.0 - 1.0;\n  normal.y = (packedNormal.y) * 2.0 - 1.0;\n#endif\n  normal.z = sqrt(1.0 - dot(normal.xy, normal.xy));\n  return normal;\n}\nSurfaceData PreCalcSurfaceData2D(float metallic, float smoothness, vec3 positionWS, vec2 uv, vec3 tangent, vec3 worldNormal)\n{\n    SurfaceData surfaceData;\n    vec3 normalWS = NormalizePerPixel(worldNormal);\n    surfaceData.PositionWS = positionWS.xyz;\n    surfaceData.NormalWS = normalWS;\n    surfaceData.Smoothness = smoothness;\n    surfaceData.Metallic = metallic;\n    surfaceData.uv = uv;\n    return surfaceData;\n}\nPBRVariables PreCalcPBRVariables(SurfaceData surfaceData, vec3 Albedo)\n{\n    float Metallic              = clamp(surfaceData.Metallic, 0.0, 1.0);\n    float Smoothness            = clamp(surfaceData.Smoothness, 0.0, 1.0);\n    float PerceptualRoughness   = PerceptualSmoothnessToPerceptualRoughness(Smoothness);\n    float Roughness             = max(PerceptualRoughnessToRoughness(PerceptualRoughness), 0.0078125);\n    float Roughness2            = max(Roughness * Roughness, 6.103515625e-5);\n    float NormalizationTerm     = Roughness * 4.0 + 2.0;\n    float Roughness2MinusOne    = max(Roughness2, 6.103515625e-5) - 1.0;\n    float oneMinusReflectivity = (1.0 - Metallic) * 0.96;\n    vec3 diffuseColor = Albedo.rgb * oneMinusReflectivity;\n    vec3 F0 = mix(vec3(0.04, 0.04, 0.04), Albedo.rgb, Metallic);\n    PBRVariables pbrVariables;\n    pbrVariables.PerceptualRoughness = PerceptualRoughness;\n    pbrVariables.Roughness = Roughness;\n    pbrVariables.Roughness2 = Roughness2;\n    pbrVariables.Roughness2MinusOne = Roughness2MinusOne;\n    pbrVariables.NormalizationTerm = NormalizationTerm;\n    pbrVariables.F0 = F0;\n    pbrVariables.DiffuseColor = diffuseColor;\n    pbrVariables.viewDir = vec3(0.0, 0.0, 1.0);\n    pbrVariables.NdotV = clamp(dot(surfaceData.NormalWS, pbrVariables.viewDir), 0.001, 1.0);\n    return pbrVariables;\n}\nvec3 SingleLightPBR(vec3 lightDir, vec3 lightColor, PBRVariables pbrVariables, SurfaceData surfaceData, float distanceAttenuation)\n{\n    vec3 HalfDir = normalize(lightDir + pbrVariables.viewDir);\n    float NdotH = clamp(dot(surfaceData.NormalWS, HalfDir), 0.0, 1.0);\n    float NdotL = clamp(dot(surfaceData.NormalWS, lightDir), 0.0, 1.0);\n#if USE_LAMBERT_WEIGHT\n    NdotL = NdotL * NdotLWeight + (1.0 - NdotLWeight);\n#endif\n    float LdotH = clamp(dot(lightDir, HalfDir), 0.0, 1.0);\n    float D = NdotH * NdotH * pbrVariables.Roughness2MinusOne + 1.00001;\n    float D2 = D * D;\n    float LdotH2 = LdotH * LdotH;\n    float SpecularTerm = pbrVariables.Roughness2 / (D2 * max(float(0.1), LdotH2) * pbrVariables.NormalizationTerm);\n    SpecularTerm = SpecularTerm - 6.103515625e-5;\n    SpecularTerm = clamp(SpecularTerm, 0.0, 100.0);\n    float radiance = NdotL * distanceAttenuation;\n    vec3 color = (pbrVariables.DiffuseColor + pbrVariables.F0 * SpecularTerm) * lightColor;\n    color *= radiance;\n    return color;\n}\n    void main() {\n#if USE_NORMAL_MAP\n        vec2 normalUV = v_uv0 * normalTilingOffset.xy + normalTilingOffset.zw;\n        normalUV = mod(normalUV, 1.0);\n        vec3 normalWS = unpackNormal(texture2D(bumpMap, normalUV).xy);\n#else\n        vec3 normalWS = vec3(0.0, 0.0, 1.0);\n#endif\n#if USE_ROTATOR\n        normalWS.xyz = v_rotateMatrix * normalWS.xyz;\n#endif\n#if USE_MASK_TEXTURE\n        vec4 maskTex = texture2D(maskMap, v_uv0);\n#else\n        vec4 maskTex = vec4(1.0, 1.0, 1.0, 1.0);\n#endif\n        normalWS.xy *= normalInt;\n        normalWS.z = abs(normalWS.z);\n        SurfaceData surfaceData = PreCalcSurfaceData2D(clamp(metallic * maskTex.g, 0.0, 1.0), clamp(smoothness * maskTex.r, 0.0, 1.0), v_worldPos, v_uv0, vec3(0.0), normalWS);\n        vec4 baseColor = albedoColor;\n#if USE_ALBEDO_TEXTURE\n        baseColor *= texture2D(texture, surfaceData.uv);\n#endif\n        PBRVariables pbrDatas = PreCalcPBRVariables(surfaceData, baseColor.rgb);\n        float lightReduce = pow(1.0 - clamp(distance(lightPos.xyz, v_worldPos.xyz) / lightRadio, 0.0, 1.0), max(0.0, lightReducePow));\n        vec3 lightDir = normalize(lightPos.xyz - surfaceData.PositionWS.xyz);\n        vec3 lightColor = SingleLightPBR(lightDir, lightColor.rgb * lightInt, pbrDatas, surfaceData, lightReduce);\n#if USE_SECOND_LIGHT\n        float secondLightReduce = pow(1.0 - clamp(distance(secondLightPos.xyz, v_worldPos.xyz) / secondLightRadio, 0.0, 1.0), max(0.0, secondLightReducePow));\n        vec3 secondLightDir = normalize(secondLightPos.xyz - surfaceData.PositionWS.xyz);\n        lightColor += SingleLightPBR(secondLightDir, secondLightColor.rgb * secondLightInt, pbrDatas, surfaceData, secondLightReduce);\n#endif\n        vec3 ambientColor = vec3(0.0, 0.0, 0.0);\n#if USE_GLOBAL_AMBIENT_COLOR\n        float rmappedNormalY = (surfaceData.NormalWS.y + 1.0) * 0.5;\n        ambientColor = mix(groundAmbient.rgb, akyAmbient.rgb, rmappedNormalY);\n        ambientColor = mix(groundLineAmbient.rgb, ambientColor, abs(surfaceData.NormalWS.y));\n        ambientColor *= pbrDatas.F0;\n        ambientColor *= ambientIntensity;\n#endif\n        vec3 emission = emissionColor.rgb * emissionIntensity * maskTex.b;\n        gl_FragColor = vec4(lightColor + emission + ambientColor, baseColor.a) * v_color;\n    }"},"glsl1":{"vert":"\n    precision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nmat3 calcRotateMatrix(vec3 rotation)\n{\n    float cosY = cos(rotation.y);\n    float cosZ = cos(rotation.z);\n    float cosX = cos(rotation.x);\n    float sinZ = sin(rotation.z);\n    float sinX = sin(rotation.x);\n    float sinY = sin(rotation.y);\n    mat3 rotationMatrix = mat3(\n    cosY * cosZ, -cosX * sinZ + sinX * sinY * cosZ, sinX * sinZ + cosX * sinY * cosZ,\n    cosY * sinZ, cosX * cosZ + sinX * sinY * sinZ, -sinX * cosZ + cosX * sinY * sinZ,\n    -sinY, sinX * cosY, cosX * cosY);\n    return rotationMatrix;\n}\nstruct SurfaceData\n{\n    vec3 PositionWS;\n    vec3 NormalWS;\n    float Smoothness;\n    float Metallic;\n    vec2 uv;\n};\nstruct PBRVariables\n{\n    float PerceptualRoughness;\n    float Roughness;\n    float Roughness2;\n    float Roughness2MinusOne;\n    float NormalizationTerm;\n    float NdotV;\n    vec3 viewDir;\n    vec3 F0;\n    vec3 DiffuseColor;\n};\n    attribute vec3 a_position;\n    attribute vec4 a_color;\n    varying vec4 v_color;\n    varying mat3 v_rotateMatrix;\n    #if USE_TEXTURE\n    attribute vec2 a_uv0;\n    varying vec2 v_uv0;\n    varying vec3 v_worldPos;\n    #endif\n    uniform vec4 rotationXYZ;\nuniform vec2 offsetXY;\n    void main () {\n        vec4 pos = vec4(a_position, 1);\n#if USE_ROTATOR\n        v_rotateMatrix = calcRotateMatrix(rotationXYZ.xyz);\n        pos.xy = pos.xy - offsetXY;\n        vec3 rotatedPos = v_rotateMatrix * pos.xyz;\n        rotatedPos.xy += offsetXY;\n#else\n        vec3 rotatedPos = pos.xyz;\n#endif\n        v_worldPos.xyz = (cc_matWorld * vec4(rotatedPos, 1.0)).xyz;\n      #if CC_USE_MODEL\n        pos = cc_matViewProj * cc_matWorld * pos;\n      #else\n        pos = cc_matViewProj * vec4(rotatedPos, 1.0);\n      #endif\n      #if USE_TEXTURE\n        v_uv0 = a_uv0;\n      #endif\n        v_color = a_color;\n        gl_Position = pos;\n    }","frag":"\n    precision highp float;\n#if USE_ALPHA_TEST\n#endif\n    varying vec4 v_color;\n    #if USE_TEXTURE\n        varying vec2 v_uv0;\n        varying vec3 v_worldPos;\n        varying mat3 v_rotateMatrix;\n        uniform sampler2D texture;\n        uniform sampler2D bumpMap;\n        uniform sampler2D maskMap;\n    #endif\n    uniform vec4 albedoColor;\nuniform vec4 emissionColor;\nuniform vec4 lightPos;\nuniform vec4 lightColor;\nuniform vec4 secondLightPos;\nuniform vec4 secondLightColor;\nuniform vec4 akyAmbient;\nuniform vec4 groundLineAmbient;\nuniform vec4 groundAmbient;\nuniform vec4 normalTilingOffset;\nuniform float metallic;\nuniform float smoothness;\nuniform float NdotLWeight;\nuniform float normalInt;\nuniform float emissionIntensity;\nuniform float lightRadio;\nuniform float lightReducePow;\nuniform float lightInt;\nuniform float secondLightRadio;\nuniform float secondLightReducePow;\nuniform float secondLightInt;\nuniform float ambientIntensity;\nstruct SurfaceData\n{\n    vec3 PositionWS;\n    vec3 NormalWS;\n    float Smoothness;\n    float Metallic;\n    vec2 uv;\n};\nstruct PBRVariables\n{\n    float PerceptualRoughness;\n    float Roughness;\n    float Roughness2;\n    float Roughness2MinusOne;\n    float NormalizationTerm;\n    float NdotV;\n    vec3 viewDir;\n    vec3 F0;\n    vec3 DiffuseColor;\n};\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\nfloat PerceptualSmoothnessToPerceptualRoughness(float perceptualSmoothness)\n{\n    return (1.0 - perceptualSmoothness);\n}\nvec3 NormalizePerPixel(vec3 vNormal)\n{\n  return normalize(vNormal);\n}\nvec3 unpackNormal(vec2 packedNormal)\n{\n  vec3 normal;\n#if REVERSE_NORMAL\n  normal.x = (1.0 - packedNormal.x) * 2.0 - 1.0;\n  normal.y = (1.0 - packedNormal.y) * 2.0 - 1.0;\n#else\n  normal.x = (packedNormal.x) * 2.0 - 1.0;\n  normal.y = (packedNormal.y) * 2.0 - 1.0;\n#endif\n  normal.z = sqrt(1.0 - dot(normal.xy, normal.xy));\n  return normal;\n}\nSurfaceData PreCalcSurfaceData2D(float metallic, float smoothness, vec3 positionWS, vec2 uv, vec3 tangent, vec3 worldNormal)\n{\n    SurfaceData surfaceData;\n    vec3 normalWS = NormalizePerPixel(worldNormal);\n    surfaceData.PositionWS = positionWS.xyz;\n    surfaceData.NormalWS = normalWS;\n    surfaceData.Smoothness = smoothness;\n    surfaceData.Metallic = metallic;\n    surfaceData.uv = uv;\n    return surfaceData;\n}\nPBRVariables PreCalcPBRVariables(SurfaceData surfaceData, vec3 Albedo)\n{\n    float Metallic              = clamp(surfaceData.Metallic, 0.0, 1.0);\n    float Smoothness            = clamp(surfaceData.Smoothness, 0.0, 1.0);\n    float PerceptualRoughness   = PerceptualSmoothnessToPerceptualRoughness(Smoothness);\n    float Roughness             = max(PerceptualRoughnessToRoughness(PerceptualRoughness), 0.0078125);\n    float Roughness2            = max(Roughness * Roughness, 6.103515625e-5);\n    float NormalizationTerm     = Roughness * 4.0 + 2.0;\n    float Roughness2MinusOne    = max(Roughness2, 6.103515625e-5) - 1.0;\n    float oneMinusReflectivity = (1.0 - Metallic) * 0.96;\n    vec3 diffuseColor = Albedo.rgb * oneMinusReflectivity;\n    vec3 F0 = mix(vec3(0.04, 0.04, 0.04), Albedo.rgb, Metallic);\n    PBRVariables pbrVariables;\n    pbrVariables.PerceptualRoughness = PerceptualRoughness;\n    pbrVariables.Roughness = Roughness;\n    pbrVariables.Roughness2 = Roughness2;\n    pbrVariables.Roughness2MinusOne = Roughness2MinusOne;\n    pbrVariables.NormalizationTerm = NormalizationTerm;\n    pbrVariables.F0 = F0;\n    pbrVariables.DiffuseColor = diffuseColor;\n    pbrVariables.viewDir = vec3(0.0, 0.0, 1.0);\n    pbrVariables.NdotV = clamp(dot(surfaceData.NormalWS, pbrVariables.viewDir), 0.001, 1.0);\n    return pbrVariables;\n}\nvec3 SingleLightPBR(vec3 lightDir, vec3 lightColor, PBRVariables pbrVariables, SurfaceData surfaceData, float distanceAttenuation)\n{\n    vec3 HalfDir = normalize(lightDir + pbrVariables.viewDir);\n    float NdotH = clamp(dot(surfaceData.NormalWS, HalfDir), 0.0, 1.0);\n    float NdotL = clamp(dot(surfaceData.NormalWS, lightDir), 0.0, 1.0);\n#if USE_LAMBERT_WEIGHT\n    NdotL = NdotL * NdotLWeight + (1.0 - NdotLWeight);\n#endif\n    float LdotH = clamp(dot(lightDir, HalfDir), 0.0, 1.0);\n    float D = NdotH * NdotH * pbrVariables.Roughness2MinusOne + 1.00001;\n    float D2 = D * D;\n    float LdotH2 = LdotH * LdotH;\n    float SpecularTerm = pbrVariables.Roughness2 / (D2 * max(float(0.1), LdotH2) * pbrVariables.NormalizationTerm);\n    SpecularTerm = SpecularTerm - 6.103515625e-5;\n    SpecularTerm = clamp(SpecularTerm, 0.0, 100.0);\n    float radiance = NdotL * distanceAttenuation;\n    vec3 color = (pbrVariables.DiffuseColor + pbrVariables.F0 * SpecularTerm) * lightColor;\n    color *= radiance;\n    return color;\n}\n    void main() {\n#if USE_NORMAL_MAP\n        vec2 normalUV = v_uv0 * normalTilingOffset.xy + normalTilingOffset.zw;\n        normalUV = mod(normalUV, 1.0);\n        vec3 normalWS = unpackNormal(texture2D(bumpMap, normalUV).xy);\n#else\n        vec3 normalWS = vec3(0.0, 0.0, 1.0);\n#endif\n#if USE_ROTATOR\n        normalWS.xyz = v_rotateMatrix * normalWS.xyz;\n#endif\n#if USE_MASK_TEXTURE\n        vec4 maskTex = texture2D(maskMap, v_uv0);\n#else\n        vec4 maskTex = vec4(1.0, 1.0, 1.0, 1.0);\n#endif\n        normalWS.xy *= normalInt;\n        normalWS.z = abs(normalWS.z);\n        SurfaceData surfaceData = PreCalcSurfaceData2D(clamp(metallic * maskTex.g, 0.0, 1.0), clamp(smoothness * maskTex.r, 0.0, 1.0), v_worldPos, v_uv0, vec3(0.0), normalWS);\n        vec4 baseColor = albedoColor;\n#if USE_ALBEDO_TEXTURE\n        baseColor *= texture2D(texture, surfaceData.uv);\n#endif\n        PBRVariables pbrDatas = PreCalcPBRVariables(surfaceData, baseColor.rgb);\n        float lightReduce = pow(1.0 - clamp(distance(lightPos.xyz, v_worldPos.xyz) / lightRadio, 0.0, 1.0), max(0.0, lightReducePow));\n        vec3 lightDir = normalize(lightPos.xyz - surfaceData.PositionWS.xyz);\n        vec3 lightColor = SingleLightPBR(lightDir, lightColor.rgb * lightInt, pbrDatas, surfaceData, lightReduce);\n#if USE_SECOND_LIGHT\n        float secondLightReduce = pow(1.0 - clamp(distance(secondLightPos.xyz, v_worldPos.xyz) / secondLightRadio, 0.0, 1.0), max(0.0, secondLightReducePow));\n        vec3 secondLightDir = normalize(secondLightPos.xyz - surfaceData.PositionWS.xyz);\n        lightColor += SingleLightPBR(secondLightDir, secondLightColor.rgb * secondLightInt, pbrDatas, surfaceData, secondLightReduce);\n#endif\n        vec3 ambientColor = vec3(0.0, 0.0, 0.0);\n#if USE_GLOBAL_AMBIENT_COLOR\n        float rmappedNormalY = (surfaceData.NormalWS.y + 1.0) * 0.5;\n        ambientColor = mix(groundAmbient.rgb, akyAmbient.rgb, rmappedNormalY);\n        ambientColor = mix(groundLineAmbient.rgb, ambientColor, abs(surfaceData.NormalWS.y));\n        ambientColor *= pbrDatas.F0;\n        ambientColor *= ambientIntensity;\n#endif\n        vec3 emission = emissionColor.rgb * emissionIntensity * maskTex.b;\n        gl_FragColor = vec4(lightColor + emission + ambientColor, baseColor.a) * v_color;\n    }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"USE_ROTATOR","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"REVERSE_NORMAL","type":"boolean","defines":[]},{"name":"USE_LAMBERT_WEIGHT","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"USE_MASK_TEXTURE","type":"boolean","defines":[]},{"name":"USE_ALBEDO_TEXTURE","type":"boolean","defines":[]},{"name":"USE_SECOND_LIGHT","type":"boolean","defines":[]},{"name":"USE_GLOBAL_AMBIENT_COLOR","type":"boolean","defines":[]}],"blocks":[{"name":"Input","binding":0,"members":[{"name":"rotationXYZ","type":16,"count":1},{"name":"offsetXY","type":14,"count":1}],"defines":[]},{"name":"ALPHA_TEST","binding":1,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"Constant","binding":2,"members":[{"name":"albedoColor","type":16,"count":1},{"name":"emissionColor","type":16,"count":1},{"name":"lightPos","type":16,"count":1},{"name":"lightColor","type":16,"count":1},{"name":"secondLightPos","type":16,"count":1},{"name":"secondLightColor","type":16,"count":1},{"name":"akyAmbient","type":16,"count":1},{"name":"groundLineAmbient","type":16,"count":1},{"name":"groundAmbient","type":16,"count":1},{"name":"normalTilingOffset","type":16,"count":1},{"name":"metallic","type":13,"count":1},{"name":"smoothness","type":13,"count":1},{"name":"NdotLWeight","type":13,"count":1},{"name":"normalInt","type":13,"count":1},{"name":"emissionIntensity","type":13,"count":1},{"name":"lightRadio","type":13,"count":1},{"name":"lightReducePow","type":13,"count":1},{"name":"lightInt","type":13,"count":1},{"name":"secondLightRadio","type":13,"count":1},{"name":"secondLightReducePow","type":13,"count":1},{"name":"secondLightInt","type":13,"count":1},{"name":"ambientIntensity","type":13,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]},{"name":"bumpMap","type":29,"count":1,"binding":31,"defines":["USE_TEXTURE"]},{"name":"maskMap","type":29,"count":1,"binding":32,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"forward-lit|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"albedoColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"emissionColor":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissionIntensity":{"type":13,"value":[1]},"maskMap":{"value":"white","type":29},"bumpMap":{"value":"white","type":29},"normalTilingOffset":{"type":16,"value":[1,1,1,1]},"normalInt":{"type":13,"value":[1]},"rotationXYZ":{"type":16,"value":[0,0,0,0]},"offsetXY":{"type":14,"value":[0,0]},"metallic":{"type":13,"value":[0.5]},"smoothness":{"type":13,"value":[0.5]},"NdotLWeight":{"type":13,"value":[1]},"lightPos":{"type":16,"value":[0,0,0,0]},"lightColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"lightInt":{"type":13,"value":[1.3]},"lightReducePow":{"type":13,"value":[2]},"lightRadio":{"type":13,"value":[100]},"secondLightPos":{"type":16,"value":[0,0,0,0]},"secondLightColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"secondLightInt":{"type":13,"value":[1.3]},"secondLightReducePow":{"type":13,"value":[2]},"secondLightRadio":{"type":13,"value":[100]},"ambientIntensity":{"type":13,"value":[0]},"akyAmbient":{"type":16,"value":[0.212,0.227,0.259,1],"editor":{"type":"color"}},"groundLineAmbient":{"type":16,"value":[0.212,0.227,0.259,1],"editor":{"type":"color"}},"groundAmbient":{"type":16,"value":[0.106,0.114,0.129,1],"editor":{"type":"color"}}}}]}]]],0,0,[],[],[]]